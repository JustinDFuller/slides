# Deconstructing Go Concurrency Concepts

Justin Fuller
Software Engineer, The New York Times
8 April 2020
https://justindfuller.com
justin.fuller@nytimes.com
@justin_d_fuller

## 

.image ./images/learn-to-code-nyt-deconstructing-go-concurrency-concepts.jpg _ 950

## Intro

üëã I'm Justin Fuller, a Software Engineer at The New York Times. 

I'm a self-taught developer with about 5 years of experience.

I've worked professionally with Java, Coldfusion, JavaScript, C#, and Go. So far, Go is my favorite!


## What is a Concurrency Concept?

* Go has implementations of concepts.
* Concept examples
  * WaitGroup
  * Mutex
  * Pool
  * Channel

## How do you deconstruct a concept?

1. Define
    * Agree on a clear explanation of what an implementation of the concept would accomplish.

2. Use
    * If an implementation already exists, start with that.

3. Create
    * After using any existing implementations, write and use your own.

## First, a little code.

At this point, we are naive programmers with no concurrency concepts to aid us.

.play 0-naive-concurrency.go /func main/,

## Our First Concept

The current code doesn't work as expected. All the logs should be printed before "done".

We need a concurrency tool that tracks the number of in-progress operations, then waits for all operations to complete.

We will accomplish this with a __WaitGroup__.

## sync.WaitGroup

Now that we've defined what we need, we use an existing implementation of WaitGroup from Go's `sync` package.

.play 1-waitgroup.go /func main/,

## Custom WaitGroup

We have defined what a waitgroup should do. We have used an existing implementation. It's time to create our own.

.play 2-customwaitgroup.go /type WaitGroup/,

## Filling in the logic 

Could it really be this simple? üôå

.play 3-race-condition-waitgroup.go /type WaitGroup/,

## Race Detector üïµÔ∏è‚Äç‚ôÄÔ∏è

```
‚ùØ go run -race 3-race-condition-waitgroup.go
Saw i = 0
Saw i = 1
==================
WARNING: DATA RACE
Read at 0x00c000136008 by goroutine 7:
  main.(*WaitGroup).Done()
      /Users/justin/code/presentation/3-race-condition-waitgroup.go:29 +0x3a
  main.main.func1()
      /Users/justin/code/presentation/3-race-condition-waitgroup.go:13 +0x123

Previous write at 0x00c000136008 by main goroutine:
  main.(*WaitGroup).Add()
      /Users/justin/code/presentation/3-race-condition-waitgroup.go:25 +0x86
  main.main()
      /Users/justin/code/presentation/3-race-condition-waitgroup.go:9 +0x67

Goroutine 7 (running) created at:
  main.main()
      /Users/justin/code/presentation/3-race-condition-waitgroup.go:10 +0xbd
==================
```

## Demonstrating the race condition

_Note: I would not consider this correct usage of a WaitGroup._

.play 4-demonstrate-race-condition.go /func main/,

## Preventing Race Conditions

It's time to define a new concept before we deconstruct it.

We need to prevent _conflicting access_ to the WaitGroup's counter. To accomplish this we will use a lock, or __Mutex__.

The goal of a mutex is to prevent conflicting access to data, ensuring that updates happen as expected.

## Lock It Down üîí

We've defined a Mutex, now we use an existing implementation. Again, we start with Go's `sync` package.

.play 5-mutex.go /type WaitGroup/,

## Build Your Own

Just like before, we start with an empty shell that fulfills sync.Mutex's signature, but not behavior. The race condition reappears.

.play 6-custom-mutex.go /type Mutex/,

## Filling It In

.play 7-naive-mutex.go /type Mutex/,

## Without a race condition.

.play 8-channel-mutex.go /const/,

## Can we go any lower?

So far we have gone progressively "lower", first using, then writing our own WaitGroup, then Mutex.

We can't go any lower because the implementations of atomic are written in assembly.

.code 9-atomic.s

This code obtains a lock at the processor level.

## Shameless self-plug

You can find other Go ramblings on my blog at [justindfuller.com](https://justindfuller.com).

.image ./images/blog.png _ 800
